#!/usr/bin/env bash
#
# Website deployment script.
#

# Global Constants
readonly TARGET_BRANCH='main'
readonly DOCKER_COMPOSE_DEFAULT_ENV_FILE='./.env'
readonly DOCKER_COMPOSE_ENV_FILE='./src/env/.env'
readonly DOCKER_COMPOSE_DOCKER_ENV_LOCAL_FILE='./src/env/.env.docker.local'
readonly WEBSITE_STATE_UP='UP'
readonly WEBSITE_STATE_DOWN='DOWN'
readonly WEBSITE_STATE_UNKNOWN='UNKNOWN'


# Globals
WEBSITE_STATE="${WEBSITE_STATE_UNKNOWN}"
DOCKER_COMPOSE_OPTIONS="\
  --env-file ${DOCKER_COMPOSE_DEFAULT_ENV_FILE}\
  --env-file ${DOCKER_COMPOSE_ENV_FILE}"
DOCKER_COMPOSE_FILE='./docker-compose.yml'
DOCKER_COMPOSE_CONTAINER='website'


# Writes error message(s) to stderr.
function err_msg() {
  local messages="$*"

  printf "ERROR: ${messages}\n" >&2
}


# Writes message(s) to stdout.
function out_msg() {
  local messages="$*"

  printf "${messages}\n"
}


# Displays usage information.
function usage() {
  cat <<-__EOF__
usage: ${0##*/} [-h] [-f <FILE>] [-c <CONTAINER>] [-o <OPTIONS>]

Description:

  A script to deploy the website inside of a Docker container.

  In instances where an older version of Docker/Docker Compose must be utilized,
  the script provides command line options to circumvent the default
  'docker-compose.yml' file (and by extension, the 'Dockerfile') used to deploy
  this website. To "circumvent", in this context, means to duplicate
  'docker-compose.yml' and 'Dockerfile' (if needed), and make the minimum number
  of changes necessary to get these files to work on the older version of
  Docker/Docker Compose being used. Any desired changes beyond this should
  consider creating a separate deployment script.

Options:

  -h                Displays this help message and exits.

  -f <FILE>         [Optional] Indicates the Docker Compose configuration file
                    to be used. Its file path must be given relative to the root
                    directory of this repository; this also applies to the
                    'context' field of the FILE's 'build' definition. If this
                    option is given more than once, only the most recent FILE
                    provided will be used. The FILE cannot be a blank string. If
                    this option is provided, it is most likely that a custom
                    'Dockerfile' SHOULD be referred to inside of FILE. It should
                    also be noted that the default loaded '.env' file will still
                    be the '.env' file located at the root directory of this
                    repository (default loaded if the '--env-file' option from
                    Docker Compose is not provided using the '-o' option).
                    Default: ./docker-compose.yml

  -c <CONTAINER>    [Optional] A string specifying the name of the CONTAINER
                    that is used to host the website. If this option is
                    provided, it is most likely that the '-f' option was also
                    provided; the CONTAINER should correspond to the
                    'container_name' definition inside of FILE. If this option
                    is given more than once, only the most recent CONTAINER
                    provided will be used. The CONTAINER cannot be a blank
                    string.
                    Default: "website"

  -o <OPTIONS>      [Optional] A string of Docker Compose OPTIONS that are
                    utilized by a call to the 'docker-compose' program. The '-f'
                    option corresponds to the '-f, --file' option used in the
                    'docker-compose' program. If a Docker Compose option
                    requires a file, then its file path must be given relative
                    to the root directory of this repository; if no OPTIONS are
                    necessary, simply provide an empty string, "". If this
                    option is given more than once, only the most recent OPTIONS
                    provided will be used.
                    Default: "--env-file ./.env --env-file ./src/env/.env"
__EOF__
}


################################################################################
# Determines the current state of the website services (Docker containters);
# the determined state is located in the global variable $WEBSITE_STATE.
# Globals:
#   SERVICES
#   WEBSITE_STATE
# Arguments:
#   None
# Outputs:
#   Writes error message(s) to stderr.
# Returns:
#   0 if the state of the website services are determined; otherwise, non-zero
#   on error.
################################################################################
function website_get_state() {
  declare -a return_codes

  docker ps --format "table {{.ID}}\t{{.Names}}" 2> /dev/null \
    | grep -q "${DOCKER_COMPOSE_CONTAINER}"
  return_codes=( "${PIPESTATUS[@]}" )
  if (( return_codes[0] != 0 )); then
    err_msg "Failed to get a list of running Docker containers."
    WEBSITE_STATE="${WEBSITE_STATE_UNKNOWN}"
    return 1
  elif (( return_codes[1] == 0 )); then
    WEBSITE_STATE="${WEBSITE_STATE_UP}"
  else
    WEBSITE_STATE="${WEBSITE_STATE_DOWN}"
  fi
}


################################################################################
# Shuts down the website.
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes shutdown step(s) to stdout; writes error message(s) to stderr.
# Returns:
#   0 if website shutdown successfully; otherwise, non-zero on error.
################################################################################
function website_down() {
  out_msg "\nAttempting to shutdown website services (Docker containers)..."
  if ! docker-compose --file "${DOCKER_COMPOSE_FILE}" down --volumes; then
    err_msg "Failed to shutdown website services."
    return 1
  fi
  out_msg "Website services shutdown."
}


################################################################################
# Starts up the website.
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes start up step(s) to stdout; writes error message(s) to stderr.
# Returns:
#   0 if the website starts up successfully; otherwise, non-zero on error.
################################################################################
function website_up() {
  out_msg "\nAttempting to startup website services (Docker containers)..."
  docker-compose --file "${DOCKER_COMPOSE_FILE}" ${DOCKER_COMPOSE_OPTIONS} \
    up --detach --build
  if (( $? != 0 )); then
    err_msg "Failed to startup website services."
    # err_msg "Possible invalid "
    return 1
  fi
  out_msg "Website services are up."
}


################################################################################
# Verifies that the $TARGET_BRANCH is the active git branch; otherwise, attempts
# to switch to it.
# Globals:
#   TARGET_BRANCH
# Arguments:
#   None
# Outputs:
#   Writes branch verificiation step(s) to stdout; writes error message(s) to
#   stderr.
# Returns:
#   0 if the $TARGET_BRANCH is set as the current branch; otherwise, non-zero on
#   error.
################################################################################
function verify_branch() {
  local current_branch

  out_msg "\nVerifying if repository's current branch is '${TARGET_BRANCH}'..."

  current_branch="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
  if (( $? != 0 )); then
    err_msg "Unable to obtain repository's current branch."
    return 1
  fi

  if [[ "${current_branch}" == "${TARGET_BRANCH}" ]]; then
    out_msg "Confirmed."
    return 0
  fi

  out_msg "Current branch is '${current_branch}'; switching to " \
          "'${TARGET_BRANCH}' branch..."
  if ! git switch "${TARGET_BRANCH}"; then
    err_msg "Failed to switch to '${TARGET_BRANCH}' branch."
    return 1
  fi
  out_msg "The current branch is now '${TARGET_BRANCH}'."
}


################################################################################
# Pulls the lastest changes from origin.
# Globals:
#   TARGET_BRANCH
#   WEBSITE_STATE
# Arguments:
#   None
# Outputs:
#   Writes pull step(s) to stdout; writes error message(s) to stderr.
# Returns:
#   0 if changes successfully pulled or if repository is already up-to-date;
#   otherwise, non-zero on error.
################################################################################
function pull_changes() {
  local head_hash
  local upstream_hash

  out_msg "\nDetermining if any changes exist from origin/${TARGET_BRANCH}..."

  if ! git fetch origin &> /dev/null; then
    err_msg "Unable to fetch changes for origin/${TARGET_BRANCH}."
    return 1
  fi

  head_hash="$(git rev-parse HEAD 2> /dev/null)"
  if (( $? != 0 )); then
    err_msg "Unable to obtain local HEAD commit hash."
    return 1
  fi

  upstream_hash="$(git rev-parse ${TARGET_BRANCH}@{upstream} 2> /dev/null)"
  if (( $? != 0 )); then
    err_msg "Unable to obtain origin/${TARGET_BRANCH} HEAD commit hash."
    return 1
  fi

  if [[ "${head_hash}" == "${upstream_hash}" ]]; then
    out_msg "Current branch is up-to-date with origin/${TARGET_BRANCH}."
    return 0
  else
    out_msg "Changes found!"
  fi

  website_get_state
  case "${WEBSITE_STATE}" in
    "${WEBSITE_STATE_UP}")    website_down || return 1 ;;
    "${WEBSITE_STATE_DOWN}")  ;;
    *)                        return 1 ;;
  esac

  out_msg "\nPulling changes from origin/${TARGET_BRANCH}..."
  if ! git pull origin "${TARGET_BRANCH}"; then
    err_msg "Unable to successfully pull changes from origin/${TARGET_BRANCH}."
    return 1
  fi
  out_msg "Current branch is now up-to-date with origin/${TARGET_BRANCH}."
}


function create_docker_env_local_file() {
  local file="${DOCKER_COMPOSE_DOCKER_ENV_LOCAL_FILE}"

  out_msg "\nVerifying if '${file}' file exists..."
  if [[ ! -f "${file}" ]]; then
    out_msg "'${file}' file does not exist; creating file..."
    if ! touch "${file}"; then
      err_msg "Unable to create file: ${file}"
      return 1
    fi
    out_msg "File successfully created."
  else
    out_msg "File already exists."
  fi
}


# Entry point of this script.
function main() {
  local script_dir

  while getopts ":hf:c:o:" opt; do
    case "${opt}" in
      h)
        usage
        exit 0
        ;;
      f)
        if [[ -z "${OPTARG// }" ]]; then
          err_msg "'-f' option given a blank string."
          usage >&2
          exit 1
        fi
        DOCKER_COMPOSE_FILE="${OPTARG}"
        ;;
      c)
        if [[ -z "${OPTARG// }" ]]; then
          err_msg "'-c' option given a blank string."
          usage >&2
          exit 1
        fi
        DOCKER_COMPOSE_CONTAINER="${OPTARG}"
        ;;
      o)
        DOCKER_COMPOSE_OPTIONS="${OPTARG}"
        ;;
      :)
        err_msg "'-${OPTARG}' option is missing an expected argument."
        usage >&2
        exit 1
        ;;
      *)
        err_msg "Unknown option '${OPTARG}' was provided."
        usage >&2
        exit 1
        ;;
    esac
  done
  shift "$(( OPTIND - 1 ))"

  if (( $# != 0 )); then
    err_msg "Unknown argument '$1' was provided."
    usage >&2
    exit 1
  fi


  out_msg "Obtaining full filepath of this script's parent directory..."
  script_dir="$({ cd "$(dirname "${BASH_SOURCE[0]}")" && pwd; } 2> /dev/null)"
  if (( $? != 0 )); then
    err_msg "Unable to determine full filepath of script's parent directory."
    return 1
  fi
  out_msg "Filepath: '${script_dir}'"


  out_msg "\nEntering project's root directory..."
  if ! cd "${script_dir}/.."; then
    err_msg "Failed to enter the project's root directory: '${script_dir}/..'"
    return 1
  fi
  out_msg "Project's root directory: '${script_dir}/..'"


  out_msg "\nVerifying if inside a git repository..."
  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    err_msg "This is not a git repository."
    return 1
  fi
  out_msg "Confirmed."


  # verify_branch || return 1


  # pull_changes || return 1


  # This file is not under version control, but is needed to deploy the website.
  create_docker_env_local_file || return 1


  # TODO: Remove me when done!
  out_msg "\nTaking down website..."
  website_down || return 1


  out_msg "\nDeploying website..."
  website_get_state
  case "${WEBSITE_STATE}" in
    "${WEBSITE_STATE_UP}")
      out_msg "Website is already deployed and running!"
      return 0
      ;;
    "${WEBSITE_STATE_DOWN}")
      website_up || return 1
      ;;
    *)
      err_msg "Unable to deploy website."
      return 1
      ;;
  esac
  out_msg "\nWebsite successfully deployed!"
}


main "$@"
